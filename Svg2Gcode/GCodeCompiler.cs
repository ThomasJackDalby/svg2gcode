using Dalby.GCode;
using GCode.Statements;
using GCode.Trivias;
using Svg2Gcode.Spatial;
using Utils.Spatial;

namespace Svg2Gcode
{
    public class GCodeCompiler
    {
        public static GCodeCompiler Default { get; } = new();

        private readonly double penDownPosition;
        private readonly double penUpPosition;
        private readonly double feedRate;

        public GCodeCompiler(double penDownPosition = 0, double penUpPosition = 100, double feedRate = 1000)
        {
            this.penDownPosition = penDownPosition;
            this.penUpPosition = penUpPosition;
            this.feedRate = feedRate;
        }

        public IEnumerable<StatementSyntax> Compile(SvgDocument svgDocument)
        {
            TriviaSyntax[] pretrivia =
            [
                new EndOfLineCommentTrivia($"Autogenerated using Svg2Gcode."),
                new EndOfLineCommentTrivia($"Source SVG: [{svgDocument.Name}]."),
                new EndOfLineCommentTrivia($"Date: {DateTime.Now}"),
            ];

            yield return Commands.G21_Millimetres().WithLeadingTrivia(pretrivia);
            yield return Commands.G90_AbsoluteCoordinates();
            yield return Commands.G17_XYPlane();
            yield return Commands.G94_UnitsPerMinuteFeedRateMode().WithTrailingTrivia(new EndOfLineCommentTrivia("Test"));
            yield return Commands.M3_TurnOnSpindle(1000).WithTrailingTrivia(new EndOfLineTrivia(), new EndOfLineTrivia(), new EndOfLineCommentTrivia("Main Program"));

            Path2D? previous = null;
            foreach (Path2D path in svgDocument.GetShapes().SelectMany(shape => shape.GetPaths()))
            {
                Vector2D start = path.Points[0];
                bool setFeed = false;
                if (previous is null || start.X != previous.Points.Last().X || start.Y != previous.Points.Last().Y)
                {
                    yield return Commands.G0_RapidMotion(z: penUpPosition);
                    yield return Commands.G0_RapidMotion(start.X, start.Y);
                    yield return Commands.G0_RapidMotion(z: penDownPosition);
                    setFeed = true;
                }

                for (int i = 1; i < path.Points.Length; i++)
                {
                    Vector2D point = path.Points[i];
                    double? f = setFeed ? feedRate : null;
                    setFeed = false;
                    yield return Commands.G1_CoordinatedMotion(x: point.X, y: point.Y, f: f);
                }
                previous = path;
            }

            yield return Commands.G0_RapidMotion(z: penUpPosition);
            yield return Commands.G0_RapidMotion(x: 0, y: 0);
        }    
    }
}
